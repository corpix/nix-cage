#!/usr/bin/env python
from argparse import ArgumentParser
from os import execve
from os.path import isabs, abspath, expanduser, basename, realpath, exists
from shutil import which
from shlex import quote as shell_escape
from os import environ, sep
from sys import stderr
from functools import reduce
from json import load as json_unmarshal, dump as json_marshal, dumps as json_marshal_str
from pwd import getpwnam
from string import Template
from collections import defaultdict

mount_suffixes = [
    "ro",
    "rw",
    "dev",
    "tmpfs"
]

def get_default_config():
    return {
        "mode": "expand", # or replace all dictionary values
        "mounts": {
            "rw":    ["."], # [(from, to), (from, to), ...] | [to, to, ...]
            "ro":    ["/"], # [(from, to), (from, to), ...] | [to, to, ...]
            "dev":   ["/dev"], # [(from, to), (from, to), ...] | [to, to, ...]
            "tmpfs": list(
                filter(
                    exists,
                    [
                        "/tmp",
                        "/home",
                        "/run/user",
                        "/run/user/{UID}".format(**environ),
                        "/run/media",
                        "/run/media/{USER}".format(**environ)
                    ]
                )
            ), # [to, to, ...]
        },
        "environment": {
            "HOME":  environ["HOME"],
            "TERM":  environ["TERM"],
            "SHELL": environ["SHELL"],
        },
        "arguments": {
            "command": environ["SHELL"],
            "bwrap": [
                "--die-with-parent",
                "--unshare-ipc",
                "--unshare-cgroup",
                "--unshare-uts",
                "--hostname", "localhost"
            ],
            "nix-shell":  [],
        }
    }

def realpathwhich(v):
    path = which(v)
    if path:
        return realpath(path)
    return v

def expand(v, ctx=environ):
    return Template(expanduser(v)).substitute(defaultdict(str, ctx))

def split_path(v):
    buf = ""
    res = []

    for c in v:
        if c == sep:
            if len(buf) > 0:
                res.append(buf)
                buf = ""
            res.append(c)
        else:
            buf += c

    if len(buf) > 0:
        res.append(buf)

    return res

def merge(source, destination, mode="expand"):
    if not mode in set(["expand", "replace"]):
        raise RuntimeError("unsupported mode {}, it could be expand or replace".format(mode))
    for key, value in source.items():
        if isinstance(value, dict):
            node = destination.setdefault(key, {})
            merge(value, node, mode=mode)
        elif isinstance(value, list) and mode == "expand":
            destination[key] = value + destination.get(key, [])
        else:
            destination[key] = value
    return destination

def get_user(user):
    p = getpwnam(user)
    return {
        "user": p.pw_name,
        "uid": p.pw_uid,
        "gid": p.pw_gid
    }

def json_marshal_pretty_str(v):
    return json_marshal_str(v, indent=4)

def split_mount_suffix(v):
    for suffix in mount_suffixes:
        delimited = ":" + suffix
        if v.endswith(delimited):
            return (
                v[:-len(delimited)],
                suffix,
            )
    return (v, None)

def sorted_mounts(mounts):
    ms = []
    for k, v in mounts.items():
        for mount in v:
            ms.append(
                (k, mount,)
            )

    ws = {}
    for k1, p1 in enumerate(ms):
        w = []

        for k2, p2 in enumerate(ms):
            if k1 == k2:
                continue

            p1s = split_path(p1[1][1])
            p2s = split_path(p2[1][1])
            n = 0

            for v in p2s:
                if len(p1s) <= n or len(p2s) <= n:
                    break
                if v == p1s[n]:
                    n += 1
                else:
                    break

            if len(p1s) > len(p2s):
                n += 1

            w.append(n)

        ws[p1] = max(w)

    return map(
        lambda v: v[1],
        sorted(
            [(v, k,) for k, v in ws.items()],
            key=lambda v: v[0]
        )
    )

def make_command(config):
    command = realpathwhich("bwrap")
    mounts = list(reduce(lambda acc, v: acc + v,
                         map(lambda v: (
                             ["--ro-bind"            ] + list(v[1]) if v[0] == "ro"
                             else ["--bind"          ] + list(v[1]) if v[0] == "rw"
                             else ["--dev-bind"      ] + list(v[1]) if v[0] == "dev"
                             else ["--tmpfs", v[1][1]]              if v[0] == "tmpfs"
                             else []
                         ), sorted_mounts(config["mounts"])), []))

    env = list(reduce(lambda acc, kv: acc + ["--setenv"] + list(kv),
                      config["environment"].items(), []))

    bwrap_flags = config["arguments"]["bwrap"]
    if exists("shell.nix"):
        shell = [which("nix-shell")]
        shell_flags = config["arguments"]["nix-shell"] + [
            "--command", config["arguments"]["command"]
        ]
    else:
        shell = [which(environ.get("SHELL", "bash"))]
        shell_flags = ["-c", config["arguments"]["command"]] if config["arguments"]["command"] else []

    return command, [basename(command)] + mounts + env + bwrap_flags + shell + shell_flags

def load_config(config, arguments, rest):
    if exists(arguments["config"]):
        with open(arguments["config"], "r") as stream:
            overlay_config = json_unmarshal(stream)
            config = merge(overlay_config, config, mode=overlay_config.get("mode", config["mode"]))

    ##

    if arguments["command"]:
        config["arguments"]["command"] = arguments["command"]
    config["arguments"]["bwrap"] += rest
    for path in arguments["path"]:
        path, suffix = split_mount_suffix(path)
        if not suffix:
            suffix = "rw"
        if suffix == "tmpfs":
            config["mounts"][suffix].append(path)
        else:
            config["mounts"][suffix].append((path, path,))

    ##

    expand_mount = lambda v: (abspath(expand(v[0])), abspath(expand(v[1])),)
    for k, v in config["mounts"].items():
        config["mounts"][k] = [
            expand_mount((v, v,) if type(v) is str else v)
            for v in config["mounts"][k]
        ]
    for k, v in config["environment"].items():
        config["environment"][k] = expand(v)

    return config

def main(arguments, rest=[]):
    user = get_user(environ["USER"])
    environ["UID"] = str(user["uid"])
    environ["GID"] = str(user["gid"])

    config = load_config(get_default_config(), arguments, rest)

    if arguments["show_config"]:
        print(json_marshal_pretty_str(config))
        return

    command, flags = make_command(config)
    stderr.write(" ".join(flags) + "\n")
    execve(command, flags, environ)

if __name__ == "__main__":
    p = ArgumentParser(
        description="Nix-cage, sandboxed environments with nix-shell"
    )

    p.add_argument(
        "path",
        nargs="*",
        help=(
            "One or more directories or files which will be mounted into the sandbox. "
            "Paths inside sandbox are same as in host system. "
            "Mounts are read/write by default, but you could change this by appending one "
            "of {} suffixes to the path.".format(
                "|".join([":" + v for v in mount_suffixes])
            )
        )
    )
    p.add_argument("--config", help="config file path", default="nix-cage.json")
    p.add_argument("--command", help="command to execute inside the sandbox")
    p.add_argument("--show-config", help="dumps config in JSON and exit", action="store_true")

    arguments, rest = p.parse_known_args()
    main(arguments.__dict__, rest)
